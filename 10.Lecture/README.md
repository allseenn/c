# Урок 10. Модули и динамические структуры

## Многомодульные программы

В языке Си можно компилировать каждый файл (модуль) отдельно, а потом объединить откомпилированные файлы в одну программу.

**Компилятор** — получает из каждой единицы трансляции код на машинном языке (Ассемблер) и генерирует объектный модуль с машинным кодом.

**Препроцессор** — компонент, производящий набор текстовых подстановок над файлом для получения его окончательного вида и передачи компилятору. Подстановка текстов заголовочных файлов (директива #include), условная трансляция, макроподстановки.

**Линковщик** — обеспечивает слияние нескольких объектных файлов в один исполняемый.

### Процесс компиляции

1. Файл с исходным кодом на СИ обрабатывается **препроцессором**: 
- Вставка кода из заголовочных файлов
- Макроподстановки
- Замена констант значениями
- И др.
2. Обработанный код СИ переводится в язык ассемблер:
- Перевод команд СИ в инструкции для процессора
- Разметка ячеек памяти (переменных) как глобальные или статические
3. Перевод инструкций ассамблера в машинной код
- инстркции и данные представленны в виде последовательности единиц и нулей
- на выходе получается объектный файла, содержащий нули и единицы
4. Линковка
- объединение нескольких объектных файлов в один исполняемый файл (программу)

### Классы памяти

Все переменные (кроме блочных) и функции в Си по умолчанию видны из всех файлов. Можно использовать ключевое слово global, чтобы дополнительно подчеркнуть это. 

В языке Си определены 4 класса памяти, определяющих область видимости: 
- auto — переменная создается при входе в блок (функция и др.), при выходе из блока переменная уничтожается. Область видимости такой переменной - блок в котором она объявлена.
- register — рекомендует транслятору, разместить данную переменную на регистре, а не в памяти.
- static — переменная будет существовать все время работы программы. Область видимости ограничена блоком в котором данная переменная объявлена. Глобальная переменная с таким классом будет доступна только из файла в котором она объявлена.
- extern — память  будет выделена в другом файле. Переменная будет существовать все время работы программы.

### Примеры модульности

#### 01.Компиляция отдельных файлов без заголовочного

**main.c**
```
#include <stdio.h>

extern int max(int, int); // Функция описана в др файле
int m;                    // Глобальная переменная. Видна из обоих файлов
static int sm;            // Глобальная переменная. Видна только из main.c

int main(void)
{
    int a, b;
    scanf("%d%d", &a, &b);
    m = max(a, b);
    printf("max(%d %d) = %d\n", a, b, m);
    return 0;
}
```

**func.c**
```
int max(int a, int b)
{
    return a > b ? a : b;
}
```

В терминале:
```
gcc -c -o 01main.o 01main.c # Команда создает объектный файл из исходного
gcc -c -o 01func.o 01func.c # Команда создает объектный файл из исходного
gcc -o 01prog 01func.o 01main.o # Линковка двух объектных файлов в исполняемый
```

#### 2.Компиляция отдельных файлов c заголовочным

Вынесем объявление функции max() из примера в отдельный заголовочный файл 02mylibrary.h

**02mylibraty.h**
```
int max(int, int);
```

После этого нужно добавить включить наш заголовочный файл в модули

**02main.c**
```
#include <stdio.h>
#include "02mylibrary.h" # Добавили заголовочный файл и убрали ссылку на внешнюю функцию max()
int m;

int main(void)
{
    int a, b;
    scanf("%d%d", &a, &b);
    m = max(a, b);
    printf("max(%d %d) = %d\n", a, b, m);
    return 0;
}
```

**02func.c**
```
#include "02mylibrary.h" # Добавили заголовочный файл

int max(int a, int b)
{
    return a > b ? a : b;
}
```

В терминале:
```
gcc -c -o 02main.o 02main.c 
gcc -c -o 02func.o 02func.c 
gcc -o 02prog 02func.o 02main.o
```

#### 3.Компиляция со статичной функцией max() в заголовочном файле

**03mylibrary.h**

```
static int max(int, int); // Функция доступна только из func.c
int max_3(int, int, int); // Функция доступна везде
```

**03func.c**
```
#include "03mylibrary.h"

int max_3(int a, int b, int c)
{
return max(max(a,b),c);
}

static int max(int a, int b)
{
    return a > b ? a : b;
}
```

**03main.c**

```
#include <stdio.h>
#include "03mylibrary.h"
int m;

int main(void)
{
    int a, b, c;
    scanf("%d%d%d", &a, &b, &c);
    m = max_3(a, b, c);
    printf("max(%d %d %d) = %d\n", a, b, c, m);
    return 0;
}
```

В терминале:
```
gcc -c -o 03main.o 03main.c 
gcc -c -o 03func.o 03func.c 
gcc -o 03prog 03func.o 03main.o
```

### Подключение библиотек



## Динамические структуры данных

Для линковки с дополнительными библиотеками используются ключи -l и -L.
После ключа указывают название библиотеки без префикса lib

Например линковка с математической библиотекой libm c ключом выглядит как -lm:

```
gcc -lm -o 03prog 03func.o 03main.o 
```

Если библиотека расположена в нестандартном для системы месте, то используют ключ -L

```
gcc -L/usr/local/lib -lm -o program file1.o file2.o
```

### make

Утилита **make** использует специальные make-файлы, в которых указаны зависимости файлов друг от друга и правила для их удовлетворения, на основе информации о времени последнего изменения каждого файла

make [ -f make-файл ] [ цель ]

Если ключ -f не указан, то ищется файл по умолчанию Makefile

#### Цели make

Цель - это директива в make-файле, представляет собой имя файла, который генерируется в результате
работы указанных команд. 
Целью также может служить название некоторого действия, которое будет выполнено в результате выполнения команд

Стандартные цели для сборки дистрибутивов GNU:

- all — выполнить компиляцию пакета (цель по умолчанию)
- install — установить пакет из дистрибутива (производит копирование исполняемых файлов, библиотек и документации в системные директории)
- uninstall — удалить пакет (производит удаление исполняемых файлов и библиотек из системных директорий)
- clean — очистить дистрибутив (удалить из дистрибутива объектные и исполняемые файлы созданные в процессе компиляции)
- distclean — очистить все созданные при компиляции файлы и все вспомогательные файлы созданные утилитой ./configure в процессе настройки параметров компиляции дистрибутива

#### Правила make

Правила в make-файле имеют следующий синтаксис:

```
цель1 цель2 ...: реквизит1 реквизит2 ...
<-TAB->команда1
<-TAB->команда2
...
```

#### Пример make-файла

Строки, в которых записаны команды, должны начинаться с символа табуляции.

**Makefile**

```
all: prog

prog: main.o func.o
    gcc -o prog main.o func.o

main.o: main.c mylibrary.h
    gcc -c -o main.o main.c

func.o: func.c
    gcc -c -o func.o func.c

clean:
    rm -rf *.o prog
```

## Задачи про датчик

